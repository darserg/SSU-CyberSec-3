Standard ML, Haskell, Lisp, Ruby

# Парадигмы программирования:
### *Императивное программирование* - отдаём команде машине и она их последовательно выполняет (после каждой команды есть побочный эффект)
Команды:
- Оператор присваивания
- Операция = вызов функции (часть выражения)
Оператор - команда
Выражение можно вычислить и получить значение выражение побочных действий не имеет (автоматически результат не сохраняется)
Нечистая функция - функция, которая автоматически сохраняет результат
- Оператор ветвьления
```imp
if (выражение) команда_1;
else команда_2
```
- Цикл
```imp
while (условие): команда;
```

### *Функциональное программирование* - одна из разновидностей парадигмы декларативного программирования
```func
f s1 * S2 * S3 * ... * S4 ... -> S
```
$$
\underbrace{f(a_{1}, a_{2}, a_{3}, \dots, a_{n})}_{a_{i}\in S_{i} \qquad b \in S}
$$
Чистая функция - функция для которой не нужно ничего из внешней среды, при вычислении результата функция не оставляет побочных эффектов


# Standard ML
```sml
fun f (a: int, b: int): int =
	2 * a + b
```

конструкция для определения функции в `SML`
```sml
fun <имя фукнции> (аргументы): <тип результата> =
	<выражение>
	
(выр, выр, ...)
```

Основа парадигмы - $\lambda$-исчисление

### Все сущности - функция

