Какой бы цикл не использовали, получаем итерационный процесс

*Итерационный процесс* (например, поиск числа Фибонначи)
```
0, 1, 2, 3, 4, 5, 6,  7,  8, ...
0, 1, 1, 2, 3, 5, 8, 13, 21, ...
n
-> n
i = 0; a0 = 0; a1 = 1;
while (i < n) {
	a2 = a0 + a1;
	i++;
	a0 = a1;
	a1 = a2;
} 
a0 ->
```

C(i, a0, a1, n)
```
C(0, 0, 1, 8) => 21
C(1, 1, 1, 8) => 21
C(2, 1, 2, 8) => 21
C(3, 2, 3, 8) => 21
...
C(8, 21, 34, 8) => 21
```

Главная характерная черта итерационного процесса заключается в том, что при разных начальных значениях можно получить те же данные

Итерационный процесс - процесс с разным набором параметров, где каждая операция приводит к изменению параметров.



```
0, 1, 1, 2, 3, 5, 8, 13, 21, 34
```
$n$-ое число Фибонначи
$$
fibb(n) = \left\{ \begin{array}l
0, & n = 0 \\
1, & n = 1 \\
fibb(n-1) + fibb(n-2), & n > 1
\end{array} \right.
$$


```sml
fun fibb(n: int): int = 
	if n = 0 then 0
	else if n = 1 then 1
	else fibb(n-1) + fibb(n-2)	

fibb(5)
(* fibb(4) + fibb(3) *)
(* fibb(3) + fibb(2) + fibb(2) + fibb(1)=1 *)
(* fibb(2) + fibb(1)=1 + fibb(1)=1 + fibb(0)=0 + fibb(1)=1 + fibb(0)=0 + 1 *)
(* fibb(1)=1 + fibb(0)=0 + 1 + 1 + 0 + 1 + 0 + 1 *)
(* 1 + 0 + 4 *)
(* 5 *)
```
Древовидная рекурсия

*Подстановочная модель вычисления функции:*
Чтобы вычислить значение функции, заменяем вызов функции заменяем на тело функции, куда подставлены параметры функции

$$
n! = \left\{ \begin{array}l
1, & n = 0 \\
n\cdot (n-1)!, & n> 0
\end{array}\right.
$$

```sml
fun fact (n: int): int =
	if n > 0 then n*fact(n-1)
	else 1

fact(5)
(* 5 * fact(4) *)
(* 5 * 4 * fact(3) *)
(* 5 * 4 * 3 * fact(2) *)
(* 5 * 4 * 3 * 2 * fact(1) *)
(* 5 * 4 * 3 * 2 * 1 * fact(0)=1*)
(* 120 *)
```

*Линейная рекурсия* - количество рекурсий растёт линейно, зависимо от параметров

Любой рекурсивный процесс можно превратить в итерационный процесс

```sml
fun C(i: int, a0: int, a1: int, n: int): int =
	if i < n then C(i+1, a1, a0+a1, n)
	else a0

C(0, 0, 1, 8)
(* C(1, 1, 1, 8) *)
(* C(2, 1, 2, 8) *)
(* C(3, 2, 3, 8) *)
(* C(4, 3, 5, 8) *)
(* C(5, 5, 8, 8) *)
(* C(6, 8, 13, 8) *)
(* C(7, 13, 21, 8 *)
(* C(8, 21, 34, 8)=21 *)
(* 21 *)
```
*Хвостовая рекурсия* - функция называется функцией с хвостовой рекурсией, если любой рекурсивный вызов в её теле приводит к получению значения всего вызова функции


*Косвенная рекурсия*
```sml
fun odd(n: int): bool =
	if n = 1 then true
	else if n = 0 then false
	else even(n-1)

and even (n: int): bool =
	if n = 0 then true
	else if n = 1 then false
	else odd(n-1)


```

# Структуры данных
`int` - целые числа :)
`real` - десятичные дроби
`bool` -  `true/false`
`string` - строки

`<type> list` - список какого-то типа данных (а-ля массив) `[1, 2, 3, 4, 5]`
```sml
val l = [1 + 5, 7 , 25, 4+8]
```

кортеж данных `(2, 5, 3.5, "sda")`. Тип кортежа определяется совокупностью типов, перечисленных в кортеже
$$
\underbrace{(2, 5, 3.5, \text{"sda"})}_{\mathrm{int*int*real*string}} \qquad A \times B \implies (\space, \space)
$$


Приведение типов:
```sml
real 2 + 3.5
```


```
([5,3], 3, [3.5, 7.4], [11], [[28],[13, 4]])
int list * int * real list * int list * int list list
```

```sml
type date = int * int * int
```

Ещё один тип данных - запись
```sml
{name = "Sergey", year = 2025, num = 3517, deg = 3.15}
{name: string, year: int, num: int, deg: real}
{deg: real, name: string, num: int, year: int}
{deg= 5.2, year=1915, name="Ivan", num=3815}


(3.15, 27, "str", 12): real * int * string * int
{1: real, 2: int, 3: string, 4:int}
{2 = 27, 3 = "Str", 4 = 12, 1 = 5.15}
```

Кортеж - частный случай записи


Операции:
`+ - * mod div ~ abs` - целочисленные операции
`+ - * / ~ abs` - вещественные числа
`Math.sin Math.cos` - вещественные числа
`andalso` - логическое "и"
`orelse` - логическое "или" (или иначе)
`not` - отрицание
`^` - канкатенация двух строк ( объединение строк)


Операции с кортежами:
`#i` - извлечение элемента кортежа

```sml
val a = (2.5, 7, 27)
val b = #2 a (* b = 7 *)
```

Операции с записями:
`#name`- извлечение элемента записи


# Операции со списками:
```sml
val l = [1, 2, 3, 4]
		(* 1 :: 2 :: 3 :: 4 :: [] *)
```
## Конструкторы списков
```sml
[]
```
пустой список

```sml
nill
```
пустой список

```sml
::
```
Правоассациативная операция (выполняется справа налево), называется `конс`

```sml
a :: l (* l - тип списка, a - тип элемента списка *)
```

Первый элемент списка называется *голова списка*, в пустом списке нет головы, список из всех оставшихся элементов - *хвост списка*

Получение головы списка `hd`
Получение хвоста списка `tl`
Функция `null` возвращает `true`, если список пустой, `false`, если непустой

```sml
[1, 2, 3] @ [4, 5, 6]
```
аппенд, для объединения списков (запрещено во многих заданиях)

```sml
fun append(l1: int list, l2: int list): int list =
	if null l1 then l2
	else hd l1 :: append(tl l1, l2)
```


# Композиция
```sml
val f' = f o g
```
g: t_0 -> t_1
f: t_1 -> t_2
f':  t_0 ->cos sin (x)

# Объекты первого класса
Объектами первого класса называются сущности, которые:
1. Можно именовать (присвоить как значение переменной)
2. Можно сохранить как значение поля или значение элемента в сложной структуре данных
3. Можно передавать в качестве аргумента в подпрограмму
4. Можно выдавать в качестве значения функции


Функции в `SML` являются объектами первого класса


```sml
fun map (f: int -> l: int list): int list =
	if null l then m
	else f (hd l) :: map(f, tl f)
```

```sml
fun add1 (x: int): int = x + 1
val l2 = [1, 2, 3]
val l1 = map(add1, l2)
```
# Переменная типа 
имя, которое может быть заменено на любой тип

```sml
'a
'b
'c
```


```sml
fun makeInc(n: int): int -> int =
	let
		fun f(x: int): int = x + n
	in
		f
	end
	
val f1 = makeInc(2)
val f2 = makeInc(5)
val a = f1 3 (* 5 *)
val b = f2 3 (* 8 *)
```

# Неименованные функции
Лямбды - функции могут возвращать другие функции в качестве результата